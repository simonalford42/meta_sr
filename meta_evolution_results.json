{
  "mutation": {
    "score": 0.7540766248185606,
    "score_vector": [
      0.5306041178792057,
      0.97400021996766,
      0.6089812698107315,
      0.9027208916166456
    ],
    "loc": 97,
    "code": "def mutation(self, individual, n_vars):\n    root = individual.copy()\n    nodes = []\n    def rec(node, parent, idx, depth):\n        nodes.append((node, parent, idx, depth))\n        if hasattr(node, 'children') and getattr(node, 'children') is not None:\n            for i, c in enumerate(node.children): rec(c, node, i, depth+1)\n        if getattr(node, 'left', None) is not None: rec(node.left, node, 'left', depth+1)\n        if getattr(node, 'right', None) is not None: rec(node.right, node, 'right', depth+1)\n        if getattr(node, 'child', None) is not None: rec(node.child, node, 'child', depth+1)\n    rec(root, None, None, 0)\n    if not nodes: return individual\n    sizes = np.array([max(1, n.size()) for n,_,_,_ in nodes], dtype=float)\n    depths = np.array([d for _,_,_,d in nodes], dtype=float)\n    alpha = random.random()\n    weights = (sizes**0.9) * (1 + alpha * (depths / (depths.max()+1))) + 1e-8\n    idx = int(np.random.choice(len(nodes), p=weights / weights.sum()))\n    target, parent, child_idx, depth = nodes[idx]\n    # adaptive mixture: encourage subtree on big shallow nodes, shrink/hoist on deep nodes, swap occasionally\n    p_sub = min(0.62, 0.12 + 0.58 * (sizes[idx] / sizes.max()))\n    p_shrink = 0.10 + 0.28 * (depth / (depths.max()+1))\n    p_hoist = 0.09 * (1 - sizes[idx] / sizes.max())\n    p_swap = 0.06 * (sizes[idx] / sizes.max())\n    p_point = max(0.0, 1 - (p_sub + p_shrink + p_hoist + p_swap))\n    mtype = random.choices(['point','subtree','shrink','hoist','swap'], [p_point,p_sub,p_shrink,p_hoist,p_swap])[0]\n    # produce replacement\n    try:\n        if mtype == 'point':\n            try:\n                cand = self.create_random_tree(1, n_vars, full=False)\n            except Exception:\n                cand = self.create_terminal(n_vars)\n            try:\n                if hasattr(cand, 'children') and hasattr(target, 'children'):\n                    cand.children = [c.copy() for c in target.children]\n                elif hasattr(cand, 'left') and hasattr(cand, 'right'):\n                    cand.left = getattr(target, 'left', None).copy() if getattr(target, 'left', None) is not None else None\n                    cand.right = getattr(target, 'right', None).copy() if getattr(target, 'right', None) is not None else None\n                elif hasattr(cand, 'child') and getattr(target, 'child', None) is not None:\n                    cand.child = target.child.copy()\n            except Exception:\n                cand = self.create_terminal(n_vars)\n            new_sub = cand\n        elif mtype == 'subtree':\n            max_new = max(1, min(6, int(np.clip(getattr(self, 'max_size', 10) // 4, 1, 6))))\n            depth_new = random.randint(1, max_new)\n            try:\n                new_sub = self.create_random_tree(depth_new, n_vars, full=False)\n            except Exception:\n                new_sub = self.create_terminal(n_vars)\n        elif mtype == 'shrink':\n            new_sub = self.create_terminal(n_vars)\n        elif mtype == 'hoist':\n            if hasattr(target, 'children') and target.children:\n                new_sub = random.choice(target.children).copy()\n            elif getattr(target, 'left', None) is not None:\n                new_sub = target.left.copy()\n            elif getattr(target, 'right', None) is not None:\n                new_sub = target.right.copy()\n            elif getattr(target, 'child', None) is not None:\n                new_sub = target.child.copy()\n            else:\n                new_sub = self.create_terminal(n_vars)\n        else:  # swap\n            others = [i for i in range(len(nodes)) if i != idx and nodes[i][0].size() <= max(1, int(sizes.max()))]\n            if not others:\n                new_sub = self.create_terminal(n_vars)\n            else:\n                new_sub = nodes[random.choice(others)][0].copy()\n    except Exception:\n        return individual\n    # size guard with graceful fallback\n    if root.size() - target.size() + new_sub.size() > self.max_size:\n        if mtype == 'subtree':\n            new_sub = self.create_terminal(n_vars)\n            if root.size() - target.size() + new_sub.size() > self.max_size: return individual\n        elif mtype in ('point','swap','hoist'):\n            new_sub = self.create_terminal(n_vars)\n            if root.size() - target.size() + new_sub.size() > self.max_size: return individual\n        else:\n            return individual\n    new_sub = new_sub.copy()\n    if parent is None:\n        return new_sub\n    if isinstance(child_idx, int) and hasattr(parent, 'children'):\n        parent.children[child_idx] = new_sub\n    elif child_idx == 'left' and hasattr(parent, 'left'):\n        parent.left = new_sub\n    elif child_idx == 'right' and hasattr(parent, 'right'):\n        parent.right = new_sub\n    elif child_idx == 'child' and hasattr(parent, 'child'):\n        parent.child = new_sub\n    else:\n        for attr in dir(parent):\n            try:\n                if getattr(parent, attr) is target:\n                    setattr(parent, attr, new_sub); break\n            except Exception:\n                continue\n    return root"
  },
  "crossover": {
    "score": 0.6628698675911371,
    "score_vector": [
      0.17250244599556386,
      0.9804466626351291,
      0.658511072966472,
      0.8400192887673836
    ],
    "loc": 73,
    "code": "def crossover(self, parent1, parent2):\n    def get_children(n):\n        for a in (\"children\", \"args\", \"operands\"):\n            c = getattr(n, a, None)\n            if isinstance(c, list): return c\n        if hasattr(n, \"left\") or hasattr(n, \"right\"):\n            return [getattr(n, \"left\", None), getattr(n, \"right\", None)]\n        return []\n    def set_child(parent, idx, child):\n        for a in (\"children\", \"args\", \"operands\"):\n            c = getattr(parent, a, None)\n            if isinstance(c, list):\n                c[idx] = child; return True\n        if hasattr(parent, \"left\") or hasattr(parent, \"right\"):\n            if idx == 0 and hasattr(parent, \"left\"): setattr(parent, \"left\", child); return True\n            if idx == 1 and hasattr(parent, \"right\"): setattr(parent, \"right\", child); return True\n        return False\n    def traverse(root):\n        out=[]; stack=[(root,None,None,0)]\n        while stack:\n            n,p,i,d=stack.pop(); out.append((n,p,i,d))\n            ch=get_children(n)\n            for j,c in enumerate(reversed(ch)):\n                if c is not None: stack.append((c,n,len(ch)-1-j,d+1))\n        return out\n    def repr_node(n):\n        lab = getattr(n,\"name\",None) or getattr(n,\"op\",None) or getattr(n,\"symbol\",None) or getattr(n,\"value\",None) or str(n)\n        return (lab, tuple(repr_node(c) for c in get_children(n) if c is not None))\n    p1 = parent1.copy(); p2 = parent2.copy()\n    nodes1 = traverse(p1); nodes2 = traverse(p2)\n    if not nodes1 or not nodes2: return p1\n    depths1 = np.array([d for _,_,_,d in nodes1], float); mid1=depths1.mean(); sigma=max(1.0, mid1/2.0)\n    w1 = np.exp(-((depths1-mid1)**2)/(2*sigma*sigma))+1e-9\n    idx1 = int(np.random.choice(len(nodes1), p=(w1/w1.sum())))\n    n1, p1_parent, i1, d1 = nodes1[idx1]\n    sem1 = max(1, n1.size())*(1+0.1*max(0, n1.height()))\n    depths2 = np.array([d for _,_,_,d in nodes2], float)\n    sem2 = np.array([max(1, n.size())*(1+0.1*max(0, n.height())) for n,_,_,_ in nodes2], float)\n    ar1 = len([c for c in get_children(n1) if c is not None]); ar2 = np.array([len([c for c in get_children(n) if c is not None]) for n,_,_,_ in nodes2])\n    depth_w = np.exp(-np.abs(depths2-d1)); sem_w = np.exp(-np.abs(sem2-sem1)/max(1.0,sem1)); ar_w = np.exp(-np.abs(ar2-ar1))\n    probs = (depth_w*sem_w*ar_w) + 1e-9; probs = probs / probs.sum()\n    max_sz = getattr(self, \"max_size\", 1e9)\n    for _ in range(4):\n        idx2 = int(np.random.choice(len(nodes2), p=probs))\n        n2 = nodes2[idx2][0]; new_size = p1.size() - n1.size() + n2.size()\n        if new_size <= max_sz: break\n        probs[idx2] *= 0.01; probs = probs / probs.sum()\n    else:\n        return parent1.copy()\n    replacement = n2.copy()\n    if p1_parent is None:\n        child = replacement\n    else:\n        child = p1\n        if not set_child(p1_parent, i1, replacement): return parent1.copy()\n    try:\n        rchild = repr_node(child)\n        if rchild == repr_node(parent1) or rchild == repr_node(parent2):\n            for _ in range(3):\n                leaves = [t for t in traverse(child) if len(get_children(t[0]))==0]\n                if not leaves: break\n                ln, lp, li, _ = random.choice(leaves)\n                if hasattr(self, \"create_terminal\"):\n                    newt = self.create_terminal(getattr(self,\"n_vars\",1)).copy()\n                else:\n                    newt = ln.copy()\n                if lp is None: child = newt\n                else: set_child(lp, li, newt)\n                if repr_node(child) != repr_node(parent1) and repr_node(child) != repr_node(parent2): break\n    except Exception:\n        pass\n    if child.size() > max_sz: return parent1.copy()\n    return child"
  }
}